Read a little more of 'Computer Systems: A Programmer's Perspective'
Read a little more of 'Linkers and Loaders' and/or LLD docs/source
Read ELF Specification
Watch 'Understanding Compiler Optimization - Chandler Carruth' on youtube

Reference for x86 machine code
    http://ref.x86asm.net/coder32.html

May be time to refactor into different c modules

GOAL 1: Make a assembler/linker for it
    Add more machine code mappings for assembler
        add enough to get it turing complete (booleans, conditionals, loops)
        //basic

        pop     r           0x58 + dst
        push    imm32         0x68, 4 bytes
        push    r           0x50 + src
        sub     r, r        0x29, rr code
        sub     eax, imm32    0x2d, 4 bytes
        sub     r, imm32      0x81, dst + 0xe8, 4 bytes 

        imul    r, r        0x0f, 0xaf, reversed rr code (src and destination are reversed when calling reg_reg_code)
        imul    r, imm32    0x69, 0xc0 + dst * 9 (why 9), 4 bytes

        //note: divide edx:eax by r
        idiv    r           0xf7, 0xf8 + r


        //TEST ALL ABOVE with basic arithmetic

        //for conditionals
        jmp     imm
        jz
        je
        cmp     r, imm
        cmp     r, r
        test    r, imm
        test    r, r
        neg     r32
        inc     r32
        sete    r8
        setl    r8
        setg    r8
        movzx   r32, r8
        xor     r, r
        call    <identifier>
        ret
        

        //TEST ALL ABOVE - should work with current compiler

GOAL 2: Linker stuff (linking multiple elf files statically)
    will each ELF object file need a relocation table (showing with addresses need to be relocated)
        is 'org' used in relocation?  Am I mixing the assembler and linker?  Or is there another relocation step in the linker too?
    symbol resolution with object files


GOAL 3: For loops, functions, switch statements, arrays and structs (and classes?), pointers/references

Assembler should allow 1 byte add/sub operations (currently defaulting to 4 byte operands when using immediates)

Tests for testing features (it's annoying to have to change test code to retest everything)
    Need way to compare input and expected output
    Make a directory called test with test .tmd files, and expected .txt(?) files
    Make a bash script to run all test and display output
    Sample output:
        locals:         passed
        conditionals:   passed
        loops:          failed

    Need tests for checking error messages too:
        tokenizing errors:  passed
        type errors:        passed
        parse errors:       failed

    write a script (put in test directory) that runs 
        and compares variable_code.tmd and variable_sol.txt (example)
        could write it in python too

TODO!!! Need to maintain conventions of registers being clobbered or preserved on function calls:
    eax, edx, and ecx are clobbered
    ebx, esi, and edi are preserved

    I'm using ebx right now to arithmetic - I should replace it with edx, ecx OR save ebx/esi/edi on stack and then restore them    

Switch statements using jump tables (call them 'when' statements)
    x: int = 7
    when x {
        is 5 {
            print("it's 5!")
        }
        is 6 {
            print("it's 6!")
        }
        is 7 {
            print("it's 7!")
        }
    }

Function definitions
    fun add(a: int, b: int) -> int {
        result: int = a + b
        -> result
    }

Need to deal with overflow with multiplication/add

Floating point arithmetic
    This will require a bit of testing in assembly to see how it works

mmap for dynamic memory allocation ....???
    memory allocation + pointers/references

Idea: compile to x86 assembly (which we can then assemble to machine code..)
    https://cs.lmu.edu/~ray/notes/nasmtutorial/

Like python, but compiled to assembly and statically type-checked
    print(3 + 7)
    x: int = 27

    if x < 30 {
        print("A") 
    }

    print("B")
    x = true #this will report an error

    for i in 10..3 by -2 {
        print(i)
    }

    fun my_add(a: int, b: int) -> {
        x: int = a + b
        -> x 
    }

    z := 25
    print(z + 4)

    a: int32 = 232
    b: int64 = 23
    c: float32
    d: float64
    e: bool
    f: char
    g: str

Get entire language compiling for arithmetic expressions
    Error
        Make a struct to hold/reorder error messages
        Need line information to make error messages better
    Lexer
        Let lexer recognize variable declaration and assignment
    Parser
        could do recursive descent or the other one (I forget the name)
        will need to define AST nodes too
        Might be easier to make p (the parser) a static variable for now 
            instead of passing a struct Parser* to all parsing functions
    Type Checker
        traverse AST once to catch type errors
    Compiler
        traverse AST again to generate IA32 assembly

    Assembler

    Linker
