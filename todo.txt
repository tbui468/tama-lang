Read a little more of 'Computer Systems: A Programmer's Perspective'
Read a little more of 'Linkers and Loaders' and/or LLD docs/source
Read ELF Specification
Watch 'Understanding Compiler Optimization - Chandler Carruth' on youtube

Reference for x86 machine code
    http://ref.x86asm.net/coder32.html

assembler_append_header(struct Assembler *a) needs to be finished

GOAL 1: Make a assembler/linker for it
        look in linkers_and_loaders directory for notes on how to do this
        probably a good idea to not use fun.asm until the entire thing can
            be successfully assembled into machine code.  Let's keep it simple guys
            Set return value to ebx (so that exit() returns it.  We can then check the return value)

        The assembler needs to write bytes to a binary file

        Instead of using Literal, use Immediate (eg, NodeImm)
            and NodeReg, and NodeDeRef (for dereferencing...?)

    Get assembler working
        assembler should parse 'org' and hex (need these two to compute _start location of program)
        write ELF header
        write the code
        write buffer to binary file

        write elf header, and track two places where final filesize is needed (two doubles)
        write out binary, compute the final file size, and the patch it into those two locations

GOAL 2: For loops, functions, switch statements, arrays and structs (and classes?), pointers/references

Tests for testing features (it's annoying to have to change test code to retest everything)
    Need way to compare input and expected output
    Make a directory called test with test .tmd files, and expected .txt(?) files
    Make a bash script to run all test and display output
    Sample output:
        locals:         passed
        conditionals:   passed
        loops:          failed

    Need tests for checking error messages too:
        tokenizing errors:  passed
        type errors:        passed
        parse errors:       failed

    write a script (put in test directory) that runs 
        and compares variable_code.tmd and variable_sol.txt (example)
        could write it in python too

TODO!!! Need to maintain conventions of registers being clobbered or preserved on function calls:
    eax, edx, and ecx are clobbered
    ebx, esi, and edi are preserved

    I'm using ebx right now to arithmetic - I should replace it with edx, ecx OR save ebx/esi/edi on stack and then restore them    

Switch statements using jump tables (call them 'when' statements)
    x: int = 7
    when x {
        is 5 {
            print("it's 5!")
        }
        is 6 {
            print("it's 6!")
        }
        is 7 {
            print("it's 7!")
        }
    }

Function definitions
    fun add(a: int, b: int) -> int {
        result: int = a + b
        -> result
    }

Need to deal with overflow with multiplication/add

Floating point arithmetic
    This will require a bit of testing in assembly to see how it works

mmap for dynamic memory allocation ....???
    memory allocation + pointers/references

Idea: compile to x86 assembly (which we can then assemble to machine code..)
    https://cs.lmu.edu/~ray/notes/nasmtutorial/

Like python, but compiled to assembly and statically type-checked
    print(3 + 7)
    x: int = 27

    if x < 30 {
        print("A") 
    }

    print("B")
    x = true #this will report an error

    for i in 10..3 by -2 {
        print(i)
    }

    fun my_add(a: int, b: int) -> {
        x: int = a + b
        -> x 
    }

    z := 25
    print(z + 4)

    a: int32 = 232
    b: int64 = 23
    c: float32
    d: float64
    e: bool
    f: char
    g: str

Get entire language compiling for arithmetic expressions
    Error
        Make a struct to hold/reorder error messages
        Need line information to make error messages better
    Lexer
        Let lexer recognize variable declaration and assignment
    Parser
        could do recursive descent or the other one (I forget the name)
        will need to define AST nodes too
        Might be easier to make p (the parser) a static variable for now 
            instead of passing a struct Parser* to all parsing functions
    Type Checker
        traverse AST once to catch type errors
    Compiler
        traverse AST again to generate IA32 assembly

    Assembler

    Linker
