Read a little more of 'Computer Systems: A Programmer's Perspective'
    next chapter - ...

Write the compiler branches for NodeGetVar and NodeSetVar
    Note: [ebp - 4] is the first value pushed onto the stack

braces, booleans, and boolean types are recognized as tokens now
Parse them (need a NodeBlock to store info)
VarData needs to take variables in outer scopes into account
    can read variables from outer scope
    declaring variables with same name will shadow variables in outer scope with same name
    should store VarDataArray inside of compiler since it will need to use it 
        also, make the compiler hold a linked list of VarDataArray (need to add a new field to vda)
            struct VarDataArray* next;
            can detach next (free and null pointers) when popping scopes
        so that we can jump to next link to go up the scope chain

Variables
    ebp is 0 initially, so we need to set it to esp before doing anything else in main
    mov     eax, [ebp - 4] gives the first value on stack (for some reason)  Why isn't it just [ebp]?
        ANSWER!!!! - we read four bytes starting from the byte with the lowest address!  The first 4 bytes
            pushed onto the stack start on the address [ebp - 4]

   When we declare a variable stick it inside VarDataArray - the (index + 1) * 4 is also the offset from ebp!
        So we can access the variable using [ebp - 4 * (index + 1)]
        getting variable value into eax:
            mov     eax, [ebp - 4 * (idx + 1)]
        setting to value in eax:
            mov     [ebp - 4 * (idx + 1)], eax

Booleans (so that we can test the type checker and also prep for conditionals statements)
    include boolean operators (and, or, not, xor)

Scopes (blocks) so we can do conditionals
    need to think about how variables are popped off stack when scope ends

Free Allocated Memory
    Wrap ALL allocations in a macro (just use realloc) and track allocated/freed bytes
    check that memory is free at end of program before ending
    start by creating a free function for the structs that allocate memory

    All arrays use the same realloc pattern - abstract into a macro instead of repeating it everywhere
        this will make the code so much easier to work with

Error Reporting System
    make a struct to hold error message - will need line info inside of tokens so that we can report error location
    need to make error holders for each phase of compilation:
        Lexing, Parsing, Typing, Compiling
    rearrange the messages by line number - merge sort of something to sort messages by line number

blocks (needed for if/else/loops and also scoping)
    when a block ends we need to pop the stack of any local variables

conditional statements
    NODE_IF - can have elif/else inside of here too
        else is a single pointer to 
        elif needs to be an array of pointers since there could be none or many elifs

Add in modulus operator 
    should be easy...right?  One of the registers holds the remainder when using 'div' operation
    but what about trying to modulus with negative numbers?

Need to deal with overflow with multiplication/add

Floating point arithmetic
    This will require a bit of testing in assembly to see how it works

mmap for dynamic memory allocation ....???

Idea: compile to x86 assembly (which we can then assemble to machine code..)
    https://cs.lmu.edu/~ray/notes/nasmtutorial/

Like python, but compiled to assembly and statically type-checked
    print(3 + 7)
    x: int = 27

    if x < 30 {
        print("A") 
    }

    print("B")
    x = true #this will report an error

    for i in 10..3 by -2 {
        print(i)
    }

    fun my_add(a: int, b: int) returns (int) {
        x: int = a + b
        return x 
    }

Get entire language compiling for arithmetic expressions
    Error
        Make a struct to hold/reorder error messages
        Need line information to make error messages better
    Lexer
        Let lexer recognize variable declaration and assignment
    Parser
        could do recursive descent or the other one (I forget the name)
        will need to define AST nodes too
        Might be easier to make p (the parser) a static variable for now 
            instead of passing a struct Parser* to all parsing functions
    Type Checker
        traverse AST once to catch type errors
    Compiler
        traverse AST again to generate IA32 assembly
