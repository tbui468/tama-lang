Read a little more of Ian Lance Taylor's blog or 'Linkers and Loaders'
    to understand differences between ELF relocatable files and ELF executable files
Read ELF Specification
Watch 'Understanding Compiler Optimization - Chandler Carruth' on youtube

Start writing out README file
    can we use that markup language (not html) to format document?
        this seems like a good chance to learn something easier than html
    Motivation
        Why build this? To learn more about the tools
        Why use C? Curious about limitations
    Diagram
    Modules
        TLexer
        TParser
        Compiler
            TODO: 
                  Refactor VarData to Symbol (identifier, value, type data)
                  Refactor VarDataArray to Environment (linked list or hash table from Cebra)
                  Add IR module(s):
                      Translate to IR
                      Canonicalize IR
                      Write interface to emit assembly for x86, x86-64, ARM, etc
                      Write implementation for x86 for now
        ALexer
        AParser
        x86 Assembler
            TODO: produce non-executable ELF files (to allow linking with other files)
        Linker
            TODO: need to make this

    Building

    ELF executables have read-only and read/write sections:
        using a read/write section will require main function/global variables

Reference for x86 machine code
    http://ref.x86asm.net/coder32.html

Look at this stackoverflow post for how machine code is structured: (THIS IS REALLY GOOD!)
    https://stackoverflow.com/questions/45526209/referencing-registers-in-machine-code

******************************************Refactor to C++*********************************
Finish Assemlber class assembling <-----------------start here
    test basic assembler functionality before dealing with labels and jumps
        assemble all nodes
        writer m_buf to output file <--------------------start here
            assemble MOV
            assemble INT
        test out.bin to see if it actually runs
    Refactor NodeLabelRef and NodeLabelDef assemble() functions - just copied original functions
        define Label class - what was the difference between ref_addr and rel_jump_addr
    Need to make data structures in Assembler1 class for labels/offsets whe for labels
Switch over to c++ for these reasons:
    can switch to C if performance is necessary
    STL (vectors, unordered maps, etc) will simplify code
    a dedicated string type will simplify things further
    could use visitor pattern to let compiler catch errors when adding new nodes

************************************Misc*********************************
emit_bin() <--instead of write() or whatever I called it
emit_asm() <--instead of write() or whatever I called it
Symbol <-- instead of VarData
Environment <-- instead of VarDataArray
Generalize assembly operation nodes: ANodeOp(op, operand1, operand2) <-- just make operand1/operand2 NULL for no operand instructions)


**********************************Add linker******************************************
Write in C++ from the start to simplify
Have assembler emit linkable ELF files along with executable ELF files
    any file with 'main' function can be executable
    need to implement functions in tamarind and set main as entry point

********************************Assemble Executabel ELF********************************

class Assembler {
    public:
        Assembler(struct TokenArray ta) {
            m_ta = ta;
        }

        void emit_machine_code(const std::string& filename) {
            parse(&m_na);
            assemble(&buf);
            write_file(filename);
        }

    private:
        void parse(struct NodeArray* na) {

        } 

        void assemble(std::string buf) {

        }

        void write_file(const std::string& filename) {

        } 

    public:
        struct TokenArray m_ta;
        struct NodeArray m_na;
        std::string buf;
};

Make new assembler in C++ asm
    Make new parser
    Make new assembler
    make function emit_elf()

*Refactor to simplify switch statement (no more nesting):

    struct Instruction {
        struct Token instruction;
        struct Operand *op1; //NULL if unused
        struct Operand *op2; //NULL if unused
    };

    struct Operand {
        enum OperandType type;
    };

    struct RegOperand {
        struct Operand operand;
        struct Token reg;
    };

    struct Imm32Operand {
        struct Operand operand;
        struct Token imm;
    };

    struct Imm8Operand {
        struct Operand operand;
        struct Token imm;
    };

    struct MemOperand {
        struct Operand operand;
        struct Token reg;
        struct Token displacement;
    };

    struct LabelOperand {
        struct Operand operand;
        struct Token label;
    };

    class Operand {
        public:
            Operand(enum OperandType type) {
                m_type = type;
            }

        public: 
            enum OperandType m_type;
    };

    class RegOperand: public Operand {
        public:
            RegOperand(enum Token reg): Operand(OT_REG) {
                m_reg = reg;
            }
        public:
            enum Token m_reg;
    };

    Operand* parse_operand(struct Parser p) {
        enum Token t = parser_next(p);
        switch(t) {
            case T_L_BRACKET:
                //memory access
            case T_EAX:
                //register
            case T_LABEL_REF:
                //label
            case T_HEX:
            case T_INT:
                //immediate
        }
    }

    Instruction* parse_instruction(struct Parser p) {
        enum Token t = parser_next(p);
        switch (t) {
            case T_PUSH:
            case T_POP:
                Operand* operand = parse_operand(p);
                return new Instruction(t, operand, NULL);
            case T_RET:
            case T_LABEL_DEF:
                return new Instruction(t, NULL, NULL);
            case T_ADD:
            case T_IDIV:
                Operand* operand1 = parse_operand(p);
                Operand* operand2 = parse_operand(p);
                return new Instruction(t, operand1, operand2);
        }
    }

    Label definition is now an AStmt with no operands (both NULL)
    Label references can be computed using a function
    Immediates (8-bit and 32-bit) can be computed using a function

Assemble _print_int
    Add tokens for these instructions
    parse these instructions
    assemble these instructions - look at Intel reference for x86 

        je      print_zero
        test    eax, 0x80000000 ;hex for 2^31
        jnz     do_negative
        neg     eax
        inc     edi
        dec     edi 

    *Note: using 'div' instruction in _print_int right now
            can this be replaced with idiv, or is an unsigned division necessary here?

Test compiler driver end-to-end (with only printing booleans for now
    Uncomment code so that compiler emits assembly
    Have compiler all functions in fun.asm for now (remove comments since my assembler doesn't recognize them right now)
    x: int = 10
    x = 15
    y: int = -90
    print(5 < x)  //should print true
    print(y > x) //should print false

    //write script with conditionals and while loops
    x: int = 0
    while x < 10 {
        if x % 2 == 0 {
            print(true)
        }
        x = x + 1
    }

Test compiler driver end-to-end:
    print out 32-bit signed integers

****************************************Clean these notes up after finishing basic assembler********************

*******Need to assemble these instructions into machine code
            jmp     imm/lbl
            jz
            je
            cmp     r, imm
            cmp     r, r
            test    r, imm
            test    r, r
            neg     r32
            inc     r32
            sete    r8
            setl    r8
            setg    r8
            movzx   r32, r8
            call    <identifier>
            ret
       
            Get _print_int working - should be able to print out 32-bit integers of arbitrary length (including negatives)

        Make linker to allow different modules to be compiled into object files, then the object files can be linked
            need to allow code to refer to external variables (can add external functions later)
            one.tmd
                extern c: int
                print(c)

            two.tmd
                c: int = 25

            assembler should produce one.obj and two.obj
            linker should take both object files as inputs and produce out.bin


    example: 
        add    ecx, eax
        [00000001][ 11][000][001] 0xc101 (0xc803 is the same)
        [op, d, s][MOD][REG][R/M]

        we need the 6-bit code for instructions with two register operands
        000000 add
        100010 mov
        001010 sub

    uint8_t ins = inst[INS_ADD];
    uint8_t dir = dirs[DIR_REG]; //1 is register, 0 is r/m
    uint8_t siz = sizs[SIZ_32];
    uint8_t opc = instruction | direction | size;

    uint8_t mod = mods[MOD_REG];
    uint8_t reg = regs[REG_EAX];
    uint8_t r_m = r_ms[RM_ECX];

0-4 byte prefixes - used to modify instructions
1-2 byte opcodes
    I. single byte
        ex: bit 0 in 'add' determines 8-bit or 16/32-bit registers/memory (1 by default for 32-bit systems)
            bit 1 in 'add' determines whether destination is REG (1) or R/M (0)
    II. 0x0f prefix byte + opcode
    *up to 512 instruction classes
0-1 mod-reg-r/m byte (further sub divided into bits)
    I.      MOD: 2 bits (11 means R/M is a register, else for displacement/indirect addressing?)
    II.     REG: 3 bits (one bit pattern for each of the 8 registers)
    III.    R/M: 3 bits
0-1 scaled index byte (further sub divided into bits)
    I.      Scale: 2 bits
    II.     Index: 3 bits
    III.    Base: 3 bits
0-4 displacement
0-4 immediate

May be time to refactor into different c modules
    Tokens.h
    Lexer.h
    Lexer.c

GOAL 1: Make a assembler/linker for it
    Add more machine code mappings for assembler
        add enough to get it turing complete (booleans, conditionals, loops)

        dereferencing (including shifts inside using expressions)
            mov     eax, [ebp - 4] ;moving top of stack into eax
            how does this translate into machine code?
            read stackoverflow post above about x86 machine code
        call
        ret


        //TEST ALL ABOVE - should work with current compiler
        //check out.asm and make sure ALL operations are assembled!!!

        //Need to have error messages appear for wrong inputs into assembler - there are a lot of ways to get this wrong
            eg, the first operand in an immediate value for many operations

GOAL 2: Linker stuff (linking multiple elf files statically)
    will each ELF object file need a relocation table (showing with addresses need to be relocated)
        is 'org' used in relocation?  Am I mixing the assembler and linker?  Or is there another relocation step in the linker too?
    symbol resolution with object files


GOAL 3: For loops, functions, switch statements, arrays and structs (and classes?), pointers/references

Assembler should allow 1 byte add/sub operations (currently defaulting to 4 byte operands when using immediates)
Assembler needs to check for overflow with imul

Tests for testing features (it's annoying to have to change test code to retest everything)
    Need way to compare input and expected output
    Make a directory called test with test .tmd files, and expected .txt(?) files
    Make a bash script to run all test and display output
    Sample output:
        locals:         passed
        conditionals:   passed
        loops:          failed

    Need tests for checking error messages too:
        tokenizing errors:  passed
        type errors:        passed
        parse errors:       failed

    write a script (put in test directory) that runs 
        and compares variable_code.tmd and variable_sol.txt (example)
        could write it in python too

    Tests for assembler (example of what should be tested)
        org     0x08048000 

        mov     ebx, 34
        push    ebx
        push    58
        mov     ebx, 0
        pop     ebx
        pop     ecx
        add     ebx, ecx
        sub     ebx, 8
        mov     eax, ebx
        cdq
        mov     ebx, 42
        idiv    ebx
        mov     esi, 40
        imul    eax, esi
        sub     eax, 38
        mov     ebx, eax
        mov     eax, 1
        int     0x80
        

TODO!!! Need to maintain conventions of registers being clobbered or preserved on function calls:
    eax, edx, and ecx are clobbered
    ebx, esi, and edi are preserved

    I'm using ebx right now to arithmetic - I should replace it with edx, ecx OR save ebx/esi/edi on stack and then restore them    

Switch statements using jump tables (call them 'when' statements)
    x: int = 7
    when x {
        is 5 {
            print("it's 5!")
        }
        is 6 {
            print("it's 6!")
        }
        is 7 {
            print("it's 7!")
        }
    }

Function definitions
    fun add(a: int, b: int) -> int {
        result: int = a + b
        -> result
    }

Need to deal with overflow with multiplication/add

Floating point arithmetic
    This will require a bit of testing in assembly to see how it works

mmap for dynamic memory allocation ....???
    memory allocation + pointers/references

Idea: compile to x86 assembly (which we can then assemble to machine code..)
    https://cs.lmu.edu/~ray/notes/nasmtutorial/

Like python, but compiled to assembly and statically type-checked
    print(3 + 7)
    x: int = 27

    if x < 30 {
        print("A") 
    }

    print("B")
    x = true #this will report an error

    for i in 10..3 by -2 {
        print(i)
    }

    fun my_add(a: int, b: int) -> {
        x: int = a + b
        -> x 
    }

    z := 25
    print(z + 4)

    a: int32 = 232
    b: int64 = 23
    c: float32
    d: float64
    e: bool
    f: char
    g: str

Get entire language compiling for arithmetic expressions
    Error
        Make a struct to hold/reorder error messages
        Need line information to make error messages better
    Lexer
        Let lexer recognize variable declaration and assignment
    Parser
        could do recursive descent or the other one (I forget the name)
        will need to define AST nodes too
        Might be easier to make p (the parser) a static variable for now 
            instead of passing a struct Parser* to all parsing functions
    Type Checker
        traverse AST once to catch type errors
    Compiler
        traverse AST again to generate IA32 assembly

    Assembler

    Linker
