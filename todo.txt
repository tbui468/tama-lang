Read a little more of 'Computer Systems: A Programmer's Perspective'

Add script to run after cmake is done building (to assemble, link and run output file)
    have cmake also run a script to assembly .asm and link the object file into an executable (to save time when iterating)

Add unary node path to compiler (negation)

Add in modulus operator 
    should be easy...right?  One of the registers holds the remainder when using 'div' operation
    but what about trying to modulus with negative numbers?

print keyword (need this otherwise all expressions, eg variable assignments, will print out to screen)

variables

booleans

conditional statements

Need to deal with overflow with multiplication/add

Floating point arithmetic
    This will require a bit of testing in assembly to see how it works

Idea: Might be easier to start with IA32 (Intel 32-bit assembly)
    convert current arithmetic compiler to use IA32 assembly

    Compare my assembly to what the gnu compiler / compiler explorer generates

    nasm -felf32 <file>.asm
    ld -m elf_i386 <file>.o

Idea: compile to x86 assembly (which we can then assemble to machine code..)
    https://cs.lmu.edu/~ray/notes/nasmtutorial/

Get entire language compiling for arithmetic expressions
    Error
        Make a struct to hold/reorder error messages
        Need line information to make error messages better
    Lexer
        Let lexer recognize variable declaration and assignment
    Parser
        could do recursive descent or the other one (I forget the name)
        will need to define AST nodes too
        Might be easier to make p (the parser) a static variable for now 
            instead of passing a struct Parser* to all parsing functions
    Type Checker
        traverse AST once to catch type errors
    Compiler
        traverse AST again to generate IA32 assembly
