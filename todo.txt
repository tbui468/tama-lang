**************Refactor************************
Scope/Environment/Symbol and Frames are all mixed up
Also, Environment and Scope have a lot of repeated functions/unused functions (I think?)
    Environment::add_symbol(...) is not calling Scope::add_symbol(...) - should it?

Need a Frame interface
    right now, x86Frame format is mixed inside with TmdAst code
    interface should be:
        append_parameter(....)
        add_local(...)

**************IR*************************
Read Slides13
Read lecture 14, lecture 15, lecture 16
Read 240 TAC examples

******************Emit x86 from TAC***********************
Remove translate methods from TmdAst - it's on github if I need it, and it's making compilation more complicated

Space in frame is not being reserved for temps (only parameters and locals/shadowing locals)

    Found problem!!!! <----- temps NOT being added to X86Frame right now -only paramters and locals
    we need temps too since they may need space on the stack
    Idea! - Should have X86Frame produce the temps - then it can add them automatically too
        X86Frame::new_temp(const std::string& suffix) {
            std::string t = "_t" + (m_temp_counter++) + suffix;  //suffix needed for shadowed locals
            //TODO: insert t into stack position 
            //  !But we need environment information to know stack height...
            return t;
        } 

    To solve problem above, we would have to move all (or at least most) Scope and Environment information
        into the X86Frame class.  This is also a good opportunity to refactor environment.hpp

    Let's just put all that information into Frames
        don't worry about environments - the frame is the environment
        Each frame will have a stack of scopes - get rid of the linked list since it's error-prone
        Pop and push scopes as needed
        When temps are


Finish implementing X86Generator function that outputs x86 assembly


Just store all locals and temps in stack for now (can integrate register allocater later)
fetch/store into stack, and use registers for arithmetic only (and return value)

Use assembler and linker to check if final output works
Compare to code generated by .translate method that generates x86 directly
    the .exe should be smaller (and the .asm should have fewer instructions)

Write the x86 register allocator later 

***************Allocate registers*********************
Read lecture 16
Read chapter in book
K-coloring and allocate registers for x86
Could also just assume no registers and push/pop everything for now

***************Optimization********************
Dead code elimination
    check target of each quad
    if that target is not used in operand1 or oprand2 of any other quad, delete that quad
    emit warning telling use code is unused

********************More Optimization********************
***************************Reorganize Quads basic-blocks*******************
    Each instruction after label is start of block - the leader (this takes care of function definitions)
    Start at each leader and move down quads until we find next leader - previous is end of block (also takes care of functions)
    Need to create CFG during this time (nodes are blocks, and edges (jumps) connect blocks)

    class TacBlock {
        public:
            TacLabel* m_label;
            TacQuad* m_begin;
            TacQuad* m_end; //one after end of block
    };

    std::vector<TacBlock> m_blocks;
    
    struct TacEdge {
        int m_from;
        int m_to;
        TacEdge(int from, int to): m_from(from), m_to(to) {}
    };

    std::vector<TacEdge> m_edges;


****************Control-Flow Graph**********************
What about trace scheduling? (Mentioned in Modern Compiler Implementation in C book, but not in standford lectures)

***************SSA*************************
Could transform to SSA IR and do more optimizations

*********************Documentation****************

Start writing out README file
    can we use that markup language (not html) to format document?
        this seems like a good chance to learn something easier than html
    Motivation
        Why build this? To learn more about the tools
        Why use C? Curious about limitations
    Diagram
    Modules
            TODO: produce non-executable ELF files (to allow linking with other files)
        Linker
            TODO: need to make this

    Building

    ELF executables have read-only and read/write sections:
        using a read/write section will require main function/global variables


********************Resources******************

Read a little more of Ian Lance Taylor's blog or 'Linkers and Loaders'
    to understand differences between ELF relocatable files and ELF executable files
Watch 'Understanding Compiler Optimization - Chandler Carruth' on youtube
Read more of 'Computer Systems: A Programmer's Perspective'
