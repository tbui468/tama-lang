Read a little more of 'Computer Systems: A Programmer's Perspective'
    next section on control
Read a little more of 'Linkers and Loaders'
    read chapter 2

GOAL: Get conditionals/loops/functions working, then make a assembler/linker for it

Have parser parse the seven boolean operators (check precedence table)
    ! (DONE)
    <-------arithmetic operators go here------->
    <, <=, >, >=
    ==, !=
    and
    or

Have compiler compile the seven boolean operators (need to figure out assembly to compare 0x1 and 0x0)

Boolean operators (so that we can test the type checker and also prep for conditionals statements)
    <, >, <=, >=, ==, !=, !
    and, or, xor

conditional statements
    NODE_IF - can have elif/else inside of here too
        else is a single pointer to 
        elif needs to be an array of pointers since there could be none or many elifs

Need to get Error messages for each step
    How to deal with errors in lexing, parsing and type checking?
        if error encounter while lexing, skip all characters until the next valid token...?
        if error encountered while parsing, skip line?

When too big ~2000 lines, break program up into smaller files

Function definitions
    fun add(a: int, b: int) -> int {
        result: int = a + b
        -> result
    }

Need to deal with overflow with multiplication/add

Floating point arithmetic
    This will require a bit of testing in assembly to see how it works

mmap for dynamic memory allocation ....???

Idea: compile to x86 assembly (which we can then assemble to machine code..)
    https://cs.lmu.edu/~ray/notes/nasmtutorial/

Like python, but compiled to assembly and statically type-checked
    print(3 + 7)
    x: int = 27

    if x < 30 {
        print("A") 
    }

    print("B")
    x = true #this will report an error

    for i in 10..3 by -2 {
        print(i)
    }

    fun my_add(a: int, b: int) -> {
        x: int = a + b
        -> x 
    }

    z := 25
    print(z + 4)

    a: int32 = 232
    b: int64 = 23
    c: float32
    d: float64
    e: bool
    f: char
    g: str

Get entire language compiling for arithmetic expressions
    Error
        Make a struct to hold/reorder error messages
        Need line information to make error messages better
    Lexer
        Let lexer recognize variable declaration and assignment
    Parser
        could do recursive descent or the other one (I forget the name)
        will need to define AST nodes too
        Might be easier to make p (the parser) a static variable for now 
            instead of passing a struct Parser* to all parsing functions
    Type Checker
        traverse AST once to catch type errors
    Compiler
        traverse AST again to generate IA32 assembly

    Assembler

    Linker
