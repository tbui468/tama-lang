Read a little more of 'Computer Systems: A Programmer's Perspective'
Read a little more of 'Linkers and Loaders' and/or LLD docs/source
Read ELF Specification
Watch 'Understanding Compiler Optimization - Chandler Carruth' on youtube

Start writing out README file
    can we use that markup language (not html) to format document?
        this seems like a good chance to learn something easier than html
    Motivation
        Why build this? To learn more about the tools
        Why use C? Curious about limitations
    Diagram
    Modules
        TLexer
        TParser
        Compiler
        ALexer
        AParser
        Assembler
        Linker

    Building

Reference for x86 machine code
    http://ref.x86asm.net/coder32.html

Look at this stackoverflow post for how machine code is structured: (THIS IS REALLY GOOD!)
    https://stackoverflow.com/questions/45526209/referencing-registers-in-machine-code

Get assembler working with new opcode structure <---------start here!!!!
        Move lexer into own module
            use new reserved words array (with index) to specify keywords for lexer
            remove enum SyntaxType (since we are using the index arrays for the lexer now)

        Move parser into own module
            maybe best to just have separate modules for tmd_parser and asm_parser
            there's some share functions, but not enough...
            How about restructuring Assembly Nodes to make it more inline with book format:
                I like how all the nodes where inside each other

            asm_ast.h/.c
            tmd_ast.h/.c


        Where is struct ByteArray being used?  If it's only one module, could we just put it into that module?

        should make some functions static
            look through all .c and .h files and make all functions not required outside translation unit private

        Add in other opcodes to make assembler turing complete (conditionals and loops)
            Get assembler working with byte offsets and dereferencing!!! (the ultimate goal - this is where our assembler is getting stuck)

        Make linker to allow different modules to be compiled into object files, then the object files can be linked
            need to allow code to refer to external variables (can add external functions later)
            one.tmd
                extern c: int
                print(c)

            two.tmd
                c: int = 25

            assembler should produce one.obj and two.obj
            linker should take both object files as inputs and produce out.bin


    example: 
        add    ecx, eax
        [00000001][ 11][000][001] 0xc101 (0xc803 is the same)
        [op, d, s][MOD][REG][R/M]

        we need the 6-bit code for instructions with two register operands
        000000 add
        100010 mov
        001010 sub

    uint8_t ins = inst[INS_ADD];
    uint8_t dir = dirs[DIR_REG]; //1 is register, 0 is r/m
    uint8_t siz = sizs[SIZ_32];
    uint8_t opc = instruction | direction | size;

    uint8_t mod = mods[MOD_REG];
    uint8_t reg = regs[REG_EAX];
    uint8_t r_m = r_ms[RM_ECX];

0-4 byte prefixes - used to modify instructions
1-2 byte opcodes
    I. single byte
        ex: bit 0 in 'add' determines 8-bit or 16/32-bit registers/memory (1 by default for 32-bit systems)
            bit 1 in 'add' determines whether destination is REG (1) or R/M (0)
    II. 0x0f prefix byte + opcode
    *up to 512 instruction classes
0-1 mod-reg-r/m byte (further sub divided into bits)
    I.      MOD: 2 bits (11 means R/M is a register, else for displacement/indirect addressing?)
    II.     REG: 3 bits (one bit pattern for each of the 8 registers)
    III.    R/M: 3 bits
0-1 scaled index byte (further sub divided into bits)
    I.      Scale: 2 bits
    II.     Index: 3 bits
    III.    Base: 3 bits
0-4 displacement
0-4 immediate

May be time to refactor into different c modules
    Tokens.h
    Lexer.h
    Lexer.c

GOAL 1: Make a assembler/linker for it
    Add more machine code mappings for assembler
        add enough to get it turing complete (booleans, conditionals, loops)

        dereferencing (including shifts inside using expressions)
            mov     eax, [ebp - 4] ;moving top of stack into eax
            how does this translate into machine code?
            read stackoverflow post above about x86 machine code
        call
        ret

        //for conditionals
        jmp     imm/lbl
        jz
        je
        cmp     r, imm
        cmp     r, r
        test    r, imm
        test    r, r
        neg     r32
        inc     r32
        sete    r8
        setl    r8
        setg    r8
        movzx   r32, r8
        xor     r, r
        call    <identifier>
        ret
        

        //TEST ALL ABOVE - should work with current compiler
        //check out.asm and make sure ALL operations are assembled!!!

        //Need to have error messages appear for wrong inputs into assembler - there are a lot of ways to get this wrong
            eg, the first operand in an immediate value for many operations

GOAL 2: Linker stuff (linking multiple elf files statically)
    will each ELF object file need a relocation table (showing with addresses need to be relocated)
        is 'org' used in relocation?  Am I mixing the assembler and linker?  Or is there another relocation step in the linker too?
    symbol resolution with object files


GOAL 3: For loops, functions, switch statements, arrays and structs (and classes?), pointers/references

Assembler should allow 1 byte add/sub operations (currently defaulting to 4 byte operands when using immediates)
Assembler needs to check for overflow with imul

Tests for testing features (it's annoying to have to change test code to retest everything)
    Need way to compare input and expected output
    Make a directory called test with test .tmd files, and expected .txt(?) files
    Make a bash script to run all test and display output
    Sample output:
        locals:         passed
        conditionals:   passed
        loops:          failed

    Need tests for checking error messages too:
        tokenizing errors:  passed
        type errors:        passed
        parse errors:       failed

    write a script (put in test directory) that runs 
        and compares variable_code.tmd and variable_sol.txt (example)
        could write it in python too

    Tests for assembler (example of what should be tested)
        org     0x08048000 

        mov     ebx, 34
        push    ebx
        push    58
        mov     ebx, 0
        pop     ebx
        pop     ecx
        add     ebx, ecx
        sub     ebx, 8
        mov     eax, ebx
        cdq
        mov     ebx, 42
        idiv    ebx
        mov     esi, 40
        imul    eax, esi
        sub     eax, 38
        mov     ebx, eax
        mov     eax, 1
        int     0x80
        

TODO!!! Need to maintain conventions of registers being clobbered or preserved on function calls:
    eax, edx, and ecx are clobbered
    ebx, esi, and edi are preserved

    I'm using ebx right now to arithmetic - I should replace it with edx, ecx OR save ebx/esi/edi on stack and then restore them    

Switch statements using jump tables (call them 'when' statements)
    x: int = 7
    when x {
        is 5 {
            print("it's 5!")
        }
        is 6 {
            print("it's 6!")
        }
        is 7 {
            print("it's 7!")
        }
    }

Function definitions
    fun add(a: int, b: int) -> int {
        result: int = a + b
        -> result
    }

Need to deal with overflow with multiplication/add

Floating point arithmetic
    This will require a bit of testing in assembly to see how it works

mmap for dynamic memory allocation ....???
    memory allocation + pointers/references

Idea: compile to x86 assembly (which we can then assemble to machine code..)
    https://cs.lmu.edu/~ray/notes/nasmtutorial/

Like python, but compiled to assembly and statically type-checked
    print(3 + 7)
    x: int = 27

    if x < 30 {
        print("A") 
    }

    print("B")
    x = true #this will report an error

    for i in 10..3 by -2 {
        print(i)
    }

    fun my_add(a: int, b: int) -> {
        x: int = a + b
        -> x 
    }

    z := 25
    print(z + 4)

    a: int32 = 232
    b: int64 = 23
    c: float32
    d: float64
    e: bool
    f: char
    g: str

Get entire language compiling for arithmetic expressions
    Error
        Make a struct to hold/reorder error messages
        Need line information to make error messages better
    Lexer
        Let lexer recognize variable declaration and assignment
    Parser
        could do recursive descent or the other one (I forget the name)
        will need to define AST nodes too
        Might be easier to make p (the parser) a static variable for now 
            instead of passing a struct Parser* to all parsing functions
    Type Checker
        traverse AST once to catch type errors
    Compiler
        traverse AST again to generate IA32 assembly

    Assembler

    Linker
