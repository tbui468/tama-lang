Read a little more of 'Computer Systems: A Programmer's Perspective'
    next section on control
Read a little more of 'Linkers and Loaders' and/or LLD docs/source
    read chapter 2

GOAL 1: Get loops/functions working, then make a assembler/linker for it
GOAL 2: Get switch statements, arrays and structs working

When file too big to manage, break program up into smaller .c and .h files

make a function call write_op(char* format, char* op, ...) that takes in variable arguments
    this will simplify the compiling steps significantly!!!
    write_op("pop eax");
    write_op("push eax, ebx");
    write_op("jmp   "else_block%d", c->conditional_label_counter);

fun.asm should be inserted directly into out.asm (to make it a complete asm file - just need system calls)

Tests for testing features (it's annoying to have to change test code to retest everything)
    Need way to compare input and expected output
    Make a directory called test with test .tmd files, and expected .txt(?) files
    Make a bash script to run all test and display output
    Sample output:
        locals:         passed
        conditionals:   passed
        loops:          failed

    Need tests for checking error messages too:
        tokenizing errors:  passed
        type errors:        passed
        parse errors:       failed

TODO!!! Need to maintain conventions of registers being clobbered or preserved on function calls:
    eax, edx, and ecx are clobbered
    ebx, esi, and edi are preserved

    I'm using ebx right now to arithmetic - I should replace it with edx, ecx OR save ebx/esi/edi on stack and then restore them    

Switch statements using jump tables (call them 'when' statements)
    x: int = 7
    when x {
        is 5 {
            print("it's 5!")
        }
        is 6 {
            print("it's 6!")
        }
        is 7 {
            print("it's 7!")
        }
    }

Function definitions
    fun add(a: int, b: int) -> int {
        result: int = a + b
        -> result
    }

Arrays

Structs

Need to deal with overflow with multiplication/add

Floating point arithmetic
    This will require a bit of testing in assembly to see how it works

mmap for dynamic memory allocation ....???

Idea: compile to x86 assembly (which we can then assemble to machine code..)
    https://cs.lmu.edu/~ray/notes/nasmtutorial/

Like python, but compiled to assembly and statically type-checked
    print(3 + 7)
    x: int = 27

    if x < 30 {
        print("A") 
    }

    print("B")
    x = true #this will report an error

    for i in 10..3 by -2 {
        print(i)
    }

    fun my_add(a: int, b: int) -> {
        x: int = a + b
        -> x 
    }

    z := 25
    print(z + 4)

    a: int32 = 232
    b: int64 = 23
    c: float32
    d: float64
    e: bool
    f: char
    g: str

Get entire language compiling for arithmetic expressions
    Error
        Make a struct to hold/reorder error messages
        Need line information to make error messages better
    Lexer
        Let lexer recognize variable declaration and assignment
    Parser
        could do recursive descent or the other one (I forget the name)
        will need to define AST nodes too
        Might be easier to make p (the parser) a static variable for now 
            instead of passing a struct Parser* to all parsing functions
    Type Checker
        traverse AST once to catch type errors
    Compiler
        traverse AST again to generate IA32 assembly

    Assembler

    Linker
