Computer Systems: A Programmer's Perspective might be worth looking into

Get print_int function in assembly_test/math.asm working
    need to pick a calling convention (such as microsoft's cdecl) and implement it
        what is caller-saved and callee-saved registers?

    Make the function to print multiple numbers
    Make that function work with negative numbers

    Caller-saved is call-clobbered (caller should save this shit before a function call since it may change)
        eax, edx, and ecx are call-clobbered (return values returned in eax)
            these registers are used in common operations (div, mul, etc) so they were chose to be call-clobbered
    Callee-saved is call-preserved (caller doesn't need to worry about those registers changing during a function call)
        ebx, esi, edi are call-preserved (routine should restore these register values if it uses them)

Create function call print_int (other one should be called print digit)
    that prints an integer with more than one digit

Add in ability to do signed arithmetic
    is this different for addition/subtraction vs multiplication/division?
    Need a way to print negative numbers out too

    Try to print -10, -1, 0, 1, and 10 to see what happens (hopefully 0, 1, and 10 work right)

    test    eax, 0x80000000              ;this will do a bitwise AND
                                ;ZF set based on eax and 1
    jnz     bit0_is_set         ;jump here if bit set
    ;code here if bit0 not set
    jmp     done 
    bit0_is_set:
        ;code goes here if bit0 was set
    done:

    Need to test eax vs 2 for second bit, eax vs 4 for third bit, etc
    bit 31 (last bit in a 32-bit integer) is set IF a signed number
        We need to check this bit before printing
        if set, need to change negative number to positive before printing (along with printing a '-' before the number)

Add in modulus operator 
    should be easy...right?  One of the registers holds the remainder when using 'div' operation

Floating point arithmetic
    This will require a bit of testing in assembly to see how it works

Idea: Might be easier to start with IA32 (Intel 32-bit assembly)
    convert current arithmetic compiler to use IA32 assembly

    Compare my assembly to what the gnu compiler / compiler explorer generates

    nasm -felf32 <file>.asm
    ld -m elf_i386 <file>.o

Idea: compile to x86 assembly (which we can then assemble to machine code..)
    https://cs.lmu.edu/~ray/notes/nasmtutorial/

Get entire language compiling for arithmetic expressions
    Error
        Make a struct to hold/reorder error messages
        Need line information to make error messages better
    Lexer
        Let lexer recognize variable declaration and assignment
    Parser
        could do recursive descent or the other one (I forget the name)
        will need to define AST nodes too
        Might be easier to make p (the parser) a static variable for now 
            instead of passing a struct Parser* to all parsing functions
    Type Checker
        traverse AST once to catch type errors
    Compiler
        traverse AST again to generate IA32 assembly
