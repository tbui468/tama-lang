Read a little more of 'Computer Systems: A Programmer's Perspective'
    next section on control
Read a little more of 'Linkers and Loaders'
    read chapter 2

GOAL: Get conditionals/loops/functions working, then make a assembler/linker for it

Move type checking to compiler
    have compiler_compile return an enum TokenType
    the return value can be used to do type checking

Compile NodeBlock (also need to fill in VarData and VarDataArray correctly with scopes)
    create a start_scope() and end_scope() functions to 

    VarDataArray will contain a pointer to the next scope

    vda_get_idx should be called by compiler_get_var_idx (which iterates through all scopes to find correct variable)
        will need to refactor and not call vda_get_idx directly in compiler/type checker - compiler_get_var_idx iterates through vdas
        note: compiler_get_var_idx will have to offset the index to include locals in outerscopes 
            eg, add vda->count from each higher scope to the current idx

    start_scope will add a new VarDataArray at beginning of linked list
   
    end_scope will remove first node in beginning of linked list

    compile NodeBlock

Booleans (so that we can test the type checker and also prep for conditionals statements)
    include boolean operators (and, or, not, xor)

Scopes (blocks) so we can do conditionals
    need to think about how variables are popped off stack when scope ends

blocks (needed for if/else/loops and also scoping)
    when a block ends we need to pop the stack of any local variables

conditional statements
    NODE_IF - can have elif/else inside of here too
        else is a single pointer to 
        elif needs to be an array of pointers since there could be none or many elifs

Need to get Error messages for each step
    How to deal with errors in lexing, parsing and type checking?
        if error encounter while lexing, skip all characters until the next valid token...?
        if error encountered while parsing, skip line?
        if error encountered while type checking ... what should we do?

Add in modulus operator 
    should be easy...right?  One of the registers holds the remainder when using 'div' operation
    but what about trying to modulus with negative numbers?

Need to deal with overflow with multiplication/add

Floating point arithmetic
    This will require a bit of testing in assembly to see how it works

mmap for dynamic memory allocation ....???

Idea: compile to x86 assembly (which we can then assemble to machine code..)
    https://cs.lmu.edu/~ray/notes/nasmtutorial/

Like python, but compiled to assembly and statically type-checked
    print(3 + 7)
    x: int = 27

    if x < 30 {
        print("A") 
    }

    print("B")
    x = true #this will report an error

    for i in 10..3 by -2 {
        print(i)
    }

    fun my_add(a: int, b: int) returns (int) {
        x: int = a + b
        return x 
    }

Get entire language compiling for arithmetic expressions
    Error
        Make a struct to hold/reorder error messages
        Need line information to make error messages better
    Lexer
        Let lexer recognize variable declaration and assignment
    Parser
        could do recursive descent or the other one (I forget the name)
        will need to define AST nodes too
        Might be easier to make p (the parser) a static variable for now 
            instead of passing a struct Parser* to all parsing functions
    Type Checker
        traverse AST once to catch type errors
    Compiler
        traverse AST again to generate IA32 assembly
