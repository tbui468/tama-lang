*******************Refactor********************
Make tokens for tac code and use as m_op paramter

TacT::Plus
TacT::Minus
TacT::Equal
TacT::Goto
TacT::CondGoto
TacT::Return
...

Use these instead of those from token.hpp
m_target, m_opd1, and m_opd2 should be clear based on m_op

****************Basic Blocks**********************
TEST!  Should be able to shuffle blocks, and use them to generate x86 code - the program output should be the same
    as the unshuffled version - just need to make sure we emit code for entry as usual

Implement this function in Optimizer:
    opt.eliminate_dead_code(&cfg);

    Black
    Grey
    White

    mark all blocks as black (unreachable)
    mark 'main' block as grey and put into working stack (grey is working set)
    for each block in working set:
        for each edge:
            if current_block is src and dst is black, mark it gray and put dst block on stack
        mark current_block as white (reachable)

    black blocks will be unreachable, and can be eliminated during code generation

Implement this function into Optmizer:
    opt.collapse_blocks(&cfg);
    for goto_cond, put false (or true) block directly afterwards (to make goto_ifz, essentially)
    Is there any reason to choose the true or false branch?  Does size of regions/traces make a difference?

Iterate through each block and assign registers
    analyze liveness of temps (true and local?)
    assign temps (true) to registers
    remove any register-allcoated true temps (NOT local temps since they could be used in other blocks) from frame

Iterate through allocated frame stack offsets for true/local temps and look for gaps
    if any stack offset has no true/local temps, decrement all true/local temps with higher offset to fill gap

myadd: (a: int, b: int) -> int {
    return a + b
}
main: () -> int {
    x: int = 1
    y: int = 5
    z: int = x + y
    return z
}


    entry <alignment>
myadd:
    begin_fun 4
    _t0 = a + b
    return _t0
    end_fun 
main:
    begin_fun 16
    _t1x = 1 
    _t2y = 5 
    _t3 = _t1x + _t2y
    _t4z = _t3 
    return _t4z
    end_fun 


main:
    push    ebp
    mov     ebp, esp
    sub     esp, 16
    *****this block is simplified to 3 lines******
    mov     eax, 1
    mov     [ebp + -4], eax
    mov     eax, 5
    mov     [ebp + -8], eax
    mov     eax, [ebp + -4]
    mov     ecx, [ebp + -8]
    add     eax, ecx
    mov     [ebp + -16], eax
    mov     eax, [ebp + -16]
    ******************************************
    add     esp, 16
    pop     ebp
    ret


Two registers needed (eax and ecx)

1. _t1x - live range is {2->3}
2. _t2y - live range is {2->3}
3. _t3 - live range is {3->4}
4. _t4z - live range is {4->5}

Assign each temp a register:
_t1x = eax
_t2y = ecx
_t3 = eax
_t4z = eax

mov     eax, 1
mov     ecx, 5
add     eax, ecx
mov     eax, eax - can remove
mov     eax, eax - can remove
mov     eax, eax - can remove

***************Allocate registers*********************
Need to make inference graph and do some node coloring


Read lecture 16
Read chapter in book
K-coloring and allocate registers for x86

****************SSA********************
class SSATransformer {
    std::vector<Block> create_basic_blocks(const std::vector<TacQuad>& quads);
    std::vector<SSAQuad> create_ssa_form(const std::vector<TacQuad>& quads, const std::vector<Block>& blocks);
};

Need to create basic blocks first
Then disallow reassignment (make a new temp to prevent this)
Need to track the base variable/most current derived variable so 
    that the most recent value can be used
Add phi nodes when a block has two or more predecessors that (may?) change a variable
***************Optimization********************
Compiler should accept flag to turn on/off optimizer

Read Slides13
Read lecture 14, lecture 15, lecture 16
Read 240 TAC examples

********************More Optimization********************
Copy propagation
Constant folding
Dead code elimination


***************************Reorganize Quads basic-blocks*******************
    Each instruction after label is start of block - the leader (this takes care of function definitions)
    Start at each leader and move down quads until we find next leader - previous is end of block (also takes care of functions)
    Need to create CFG during this time (nodes are blocks, and edges (jumps) connect blocks)

    class TacBlock {
        public:
            TacLabel* m_label;
            TacQuad* m_begin;
            TacQuad* m_end; //one after end of block
    };

    std::vector<TacBlock> m_blocks;
    
    struct TacEdge {
        int m_from;
        int m_to;
        TacEdge(int from, int to): m_from(from), m_to(to) {}
    };

    std::vector<TacEdge> m_edges;


****************Control-Flow Graph**********************
What about trace scheduling? (Mentioned in Modern Compiler Implementation in C book, but not in standford lectures)

***************SSA*************************
Could transform to SSA IR and do more optimizations

*********************Documentation****************

Start writing out README file
    can we use that markup language (not html) to format document?
        this seems like a good chance to learn something easier than html
    Motivation
        Why build this? To learn more about the tools
        Why use C? Curious about limitations
    Diagram
    Modules
            TODO: produce non-executable ELF files (to allow linking with other files)
        Linker
            TODO: need to make this

    Building

    ELF executables have read-only and read/write sections:
        using a read/write section will require main function/global variables


********************Resources******************

Read a little more of Ian Lance Taylor's blog or 'Linkers and Loaders'
    to understand differences between ELF relocatable files and ELF executable files
Watch 'Understanding Compiler Optimization - Chandler Carruth' on youtube
Read more of 'Computer Systems: A Programmer's Perspective'
