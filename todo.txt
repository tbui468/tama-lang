**************Refactor************************
Scope/Environment/Symbol and Frames are all mixed up
Also, Environment and Scope have a lot of repeated functions/unused functions (I think?)
    Environment::add_symbol(...) is not calling Scope::add_symbol(...) - should it?

Need a Frame interface
    right now, x86Frame format is mixed inside with TmdAst code
    interface should be:
        append_parameter(....)
        add_local(...)

**************IR*************************
Read Slides13
Read lecture 14, lecture 15, lecture 16
Read 240 TAC examples

*****************Problem with Temps NOT being properly added to reserved stack space************
    this code:
        add(3 + 4, 5)
    produces:
        push_arg 5
        _t1 = 3 + 4
        push_arg _t1
    but since _t1 is not a local (regular or shadowing), it's not inside of the frame or allocated space on the stack


    Implement and replace all calls of TacQuad::new_temp() and X86Frame::add_symbol_to_scope() with this:
        std::string X86Frame::add_temp_to_scope(const std::string& reg_name, Type type) {
            //generate unique temporary register
            //suffix that with reg_name
            //compute offset and insert into scope (can probably call this int TmdAst, instead of add_symbol_to_scope)
            //  Note about key in scope pair: if reg_name is empty string, use the temp name (since names need to be unique)
            //        else use the reg_name (compiler needs original identifier, and will take care of shadowing)

            //return suffixed temp for compiler to use
        }

******************Emit x86 from TAC***********************

Finish implementing X86Generator function that outputs x86 assembly


Just store all locals and temps in stack for now (can integrate register allocater later)
fetch/store into stack, and use registers for arithmetic only (and return value)

Use assembler and linker to check if final output works
Compare to code generated by .translate method that generates x86 directly
    the .exe should be smaller (and the .asm should have fewer instructions)

Write the x86 register allocator later 

***************Allocate registers*********************
Read lecture 16
Read chapter in book
K-coloring and allocate registers for x86
Could also just assume no registers and push/pop everything for now

***************Optimization********************
Dead code elimination
    check target of each quad
    if that target is not used in operand1 or oprand2 of any other quad, delete that quad
    emit warning telling use code is unused

********************More Optimization********************
***************************Reorganize Quads basic-blocks*******************
    Each instruction after label is start of block - the leader (this takes care of function definitions)
    Start at each leader and move down quads until we find next leader - previous is end of block (also takes care of functions)
    Need to create CFG during this time (nodes are blocks, and edges (jumps) connect blocks)

    class TacBlock {
        public:
            TacLabel* m_label;
            TacQuad* m_begin;
            TacQuad* m_end; //one after end of block
    };

    std::vector<TacBlock> m_blocks;
    
    struct TacEdge {
        int m_from;
        int m_to;
        TacEdge(int from, int to): m_from(from), m_to(to) {}
    };

    std::vector<TacEdge> m_edges;


****************Control-Flow Graph**********************
What about trace scheduling? (Mentioned in Modern Compiler Implementation in C book, but not in standford lectures)

***************SSA*************************
Could transform to SSA IR and do more optimizations

*********************Documentation****************

Start writing out README file
    can we use that markup language (not html) to format document?
        this seems like a good chance to learn something easier than html
    Motivation
        Why build this? To learn more about the tools
        Why use C? Curious about limitations
    Diagram
    Modules
            TODO: produce non-executable ELF files (to allow linking with other files)
        Linker
            TODO: need to make this

    Building

    ELF executables have read-only and read/write sections:
        using a read/write section will require main function/global variables


********************Resources******************

Read a little more of Ian Lance Taylor's blog or 'Linkers and Loaders'
    to understand differences between ELF relocatable files and ELF executable files
Watch 'Understanding Compiler Optimization - Chandler Carruth' on youtube
Read more of 'Computer Systems: A Programmer's Perspective'
