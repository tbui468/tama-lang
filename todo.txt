Read a little more of Ian Lance Taylor's blog or 'Linkers and Loaders'
    to understand differences between ELF relocatable files and ELF executable files
Read ELF Specification
Watch 'Understanding Compiler Optimization - Chandler Carruth' on youtube

Start writing out README file
    can we use that markup language (not html) to format document?
        this seems like a good chance to learn something easier than html
    Motivation
        Why build this? To learn more about the tools
        Why use C? Curious about limitations
    Diagram
    Modules
            TODO: produce non-executable ELF files (to allow linking with other files)
        Linker
            TODO: need to make this

    Building

    ELF executables have read-only and read/write sections:
        using a read/write section will require main function/global variables

Reference for x86 machine code
    http://ref.x86asm.net/coder32.html

Look at this stackoverflow post for how machine code is structured: (THIS IS REALLY GOOD!)
    https://stackoverflow.com/questions/45526209/referencing-registers-in-machine-code

New structure:
    semant.cpp <----
        lexing, parsing, type-checking, semantic analysis
    translater.cpp <--this was the old compiler
        AST to x86 assembly (can add IR modules later)
    assembler.cpp
        lex, parse, emit ELF 
    linker.cpp
        link multiple ELF object files to create executable

Modules after adding in IR:
    tmdSemant.cpp
        lexing, parsing, type-checking, symbols/environments, semantic analysis
    tmdTranslater.cpp
        AST to IR
    optimizer.cpp (could make this into seperate modules)
        canonicalize, instruction selection, liveness analysis, register allocation, constant folding, etc
    x86Emitter.cpp
        IR to architecture-specific assembly
    x86ElfAssembler.cpp
        lex, parse, emit ELF 
    elfLinker.cpp
        link multiple ELF object files to create executable

******************************************Refactor to C++*********************************

remove r_tbl and rm_tbl and replace with bit_pattern() method
    this makes it a little robust than requiring tokens types to be in correct order

    Need to automate tests for compiler - refactors are getting dangerous with just hand-written tests

Assemble logical operators
    setg    al
    setle   al
    setge   al
    sete    al
    setne   al

Arithmetic operators
    %
    
Make new C++ class called Linker (links ELF for now)
    prioritize relocation of code for now (dynamic linking and other fancy stuff comes later)
    link multiple object files (where one has a 'main' function)
    have assembler produce executables if _main symbol exists (so we don't need to implement tamarind functions yet)
        otherwise, produce libraries (just for static linking for now)

    Will need functions to fully test (but do we?  Assembler can produce object files, can't it?)
    It could but we still need to differentiate between tmd functions and asm functions part of the standard tmd library
        lib.tmd
            fun add(x:int, y:int) -> sum: int {
                sum = x + y
            }

        test.tmd
            fun main() {
                print(add(2, 3))
                print(add(5, 3))
            }

        tama lib.tmd test.tmd (produces lib.o, test.o and out.bin)

        Running out.bin should print 5 and 8

Split semantic analysis and code generation in TmdAst
    analyze() - type check and check definitions, etc
    translate() - translate to IR (currently going straight to assembly)

    Get something simple working end-to-end (these three Irt nodes should be enough ...?)
        Expr:
            call(f, l) - call function f on argument list l
            const(i) - constant integer i
        Stmt:
            exp(e) - expression evaluated and result discarded

    Canonicalize - remove discrepencies between Irt and machine-language programs (linearize)
    Group into Basic Blocks - group so that blocks contain no internal jumps/labels (group)
    Order Blocks into Traces - CJMP is immediately followed by false block (traceSchedule)

    Use Tree Patterns to select instructions (algorithms like Maximal Munch)
        this can produce an assembly language with infinite registers for now

    Analzye control flow of the temp assembly to create control-flow graph

    Analyze liveness of variables in control-flow graph to create interference graph

    Color interference graph, and for each temporary either assign a register or store in memory

    ???PDF268 says registers can be allocated for trees (rather than interference graph).
        But this causes other problems - so is it worth it? (Hard to say at this point)

Make a new C++ class called Optimizer
    Have Semant output IR trees (keep it simple for now)
    Have IRCompiler output assembly for given architecture from optimized IR
    Have x86Assembler output assembly for given file format (ELF, ECOFF, MACHO)

Switch over to c++ for these reasons:
    can switch to C if performance is necessary
    STL (vectors, unordered maps, etc) will simplify code
    a dedicated string type will simplify things further
    could use visitor pattern to let compiler catch errors when adding new nodes

